/**
 const resizeMove = {
    "nw-resize": (
      _: Offset,
      _layout: Layout,
      start: MoveStart,
      e: MouseEvent
    ) => {
      if (!e) return _layout;
      const layout = { ..._layout };
      if (layout.rotate !== 0) {
        // if (e.layerX < 0 || e.layerY < 0) return layout;
        const canvas = document.getElementsByClassName("infinite-canvas")[0];
        const editorRectInfo = canvas.getBoundingClientRect();
        const realTimeCoordinates = {
          x: (e.clientX - editorRectInfo.left) * scaleFactor.value,
          y: (e.clientY - editorRectInfo.top) * scaleFactor.value,
        };
        const centerCoordinate = getCenterCoordinate(
          realTimeCoordinates,
          start.symmetric
        );
        const currentPoint = calculateRotateCoordinate(
          realTimeCoordinates,
          centerCoordinate,
          layout.rotate
        );
        const symmetricPoint = calculateRotateCoordinate(
          start.symmetric,
          centerCoordinate,
          layout.rotate
        );
        // console.log("point", currentPoint, symmetricPoint);
        const width = symmetricPoint.x - currentPoint.x;
        const height = symmetricPoint.y - currentPoint.y;
        if (width > 0 && height > 0) {
          layout.width = width;
          layout.height = height;
          layout.x = currentPoint.x;
          layout.y = currentPoint.y;
        }
      } else {
        const scaleFactor = 1 / props.scale; // 计算缩放修正因子
        const correct = {
          x: Math.round((start.x - Number(e.clientX)) * scaleFactor),
          y: Math.round((start.y - Number(e.clientY)) * scaleFactor),
        };
        layout.width = start.width + correct.x;
        layout.height = start.height + correct.y;
        layout.x = start.layoutX - correct.x;
        layout.y = start.layoutY - correct.y;
        if (layout.height < 0) {
          layout.height = 0;
          layout.y = start.layoutY + start.height;
        }
        if (layout.width < 0) {
          layout.width = 0;
          layout.x = start.layoutX + start.width;
        }
      }
  
      return layout;
    },
    "ne-resize": (
      offset: Offset,
      _layout: Layout,
      start: MoveStart,
      e: MouseEvent
    ): Layout => {
      if (!e) return _layout;
      const layout = { ..._layout };
      if (layout.rotate !== 0) {
        if (e.layerX < 0 || e.layerY < 0) return layout;
        console.log(e);
        const canvas = document.getElementsByClassName("infinite-canvas")[0];
        const editorRectInfo = canvas.getBoundingClientRect();
        const realTimeCoordinates = {
          x: e.clientX - editorRectInfo.left,
          y: e.clientY - editorRectInfo.top,
        };
  
        const centerCoordinate = getCenterCoordinate(
          realTimeCoordinates,
          start.symmetric
        );
        const currentPoint = calculateRotateCoordinate(
          realTimeCoordinates,
          centerCoordinate,
          layout.rotate
        );
        const symmetricPoint = calculateRotateCoordinate(
          start.symmetric,
          centerCoordinate,
          layout.rotate
        );
        const width = currentPoint.x - symmetricPoint.x;
        const height = symmetricPoint.y - currentPoint.y;
        if (width > 0 && height > 0) {
          layout.width = width;
          layout.height = height;
          layout.x = symmetricPoint.x;
          layout.y = currentPoint.y;
        }
      } else {
        if (start.layoutY + offset.y < 0) {
          layout.y = 0;
          layout.height = start.height + start.layoutY;
        } else if (start.height - offset.y < 0) {
          layout.y = start.layoutY + start.height;
          layout.height = 0;
        } else {
          layout.y = start.layoutY + offset.y;
          layout.height = start.height - offset.y;
        }
        if (start.width + offset.x < 0) {
          layout.width = 0;
        } else {
          layout.width = start.width + offset.x;
        }
      }
  
      return layout;
    },
    "n-resize": (
      offset: Offset,
      _layout: Layout,
      start: MoveStart,
      e: MouseEvent
    ): Layout => {
      const layout = { ..._layout };
      if (!e) return layout;
      if (layout.rotate !== 0) {
        const canvas = document.getElementsByClassName("infinite-canvas")[0];
        const editorRectInfo = canvas.getBoundingClientRect();
        const realTimeCoordinates = {
          x: e.clientX - editorRectInfo.left,
          y: e.clientY - editorRectInfo.top,
        };
        const currentPoint = calculateRotateCoordinate(
          realTimeCoordinates,
          start.point,
          layout.rotate
        );
        const topPoint = calculateRotateCoordinate(
          {
            x: start.point.x,
            y: currentPoint.y,
          },
          start.point,
          -layout.rotate
        );
        const height = Math.sqrt(
          (topPoint.x - start.symmetric.x) ** 2 +
            (topPoint.y - start.symmetric.y) ** 2
        );
        const center = {
          x: topPoint.x - (topPoint.x - start.symmetric.x) / 2,
          y: topPoint.y + (start.symmetric.y - topPoint.y) / 2,
        };
        if (height > 0) {
          layout.height = height;
          layout.y = center.y - height / 2;
          layout.x = center.x - layout.width / 2;
        }
      } else {
        if (start.height - offset.y < 0) {
          layout.y = start.layoutY + start.height;
          layout.height = 0;
        } else {
          layout.y = start.layoutY + offset.y;
          layout.height = start.height - offset.y;
        }
      }
      return layout;
    },
    "e-resize": (
      offset: Offset,
      _layout: Layout,
      start: MoveStart,
      e: MouseEvent
    ): Layout => {
      const layout = { ..._layout };
      if (!e) return layout;
      if (layout.rotate !== 0) {
        const canvas = document.getElementsByClassName("infinite-canvas")[0];
        const editorRectInfo = canvas.getBoundingClientRect();
        const realTimeCoordinates = {
          x: e.clientX - editorRectInfo.left,
          y: e.clientY - editorRectInfo.top,
        };
        const { symmetric, point } = start;
        const currentPoint = calculateRotateCoordinate(
          realTimeCoordinates,
          point,
          layout.rotate
        );
        const rightPoint = calculateRotateCoordinate(
          {
            x: currentPoint.x,
            y: point.y,
          },
          point,
          -layout.rotate
        );
        const width = Math.sqrt(
          (rightPoint.x - symmetric.x) ** 2 + (rightPoint.y - symmetric.y) ** 2
        );
        const center = {
          x: rightPoint.x - (rightPoint.x - symmetric.x) / 2,
          y: rightPoint.y + (symmetric.y - rightPoint.y) / 2,
        };
        if (width > 0) {
          layout.width = width;
          layout.y = center.y - layout.height / 2;
          layout.x = center.x - width / 2;
        }
      } else {
        if (start.width + offset.x < 0) {
          layout.width = 0;
        } else {
          layout.width = start.width + offset.x;
        }
      }
      return layout;
    },
    "w-resize": (
      offset: Offset,
      _layout: Layout,
      start: MoveStart,
      e: MouseEvent
    ): Layout => {
      const layout = { ..._layout };
      if (layout.rotate !== 0) {
        const canvas = document.getElementsByClassName("infinite-canvas")[0];
        const editorRectInfo = canvas.getBoundingClientRect();
        const realTimeCoordinates = {
          x: e.clientX - editorRectInfo.left,
          y: e.clientY - editorRectInfo.top,
        };
        const currentPoint = calculateRotateCoordinate(
          realTimeCoordinates,
          start.point,
          layout.rotate
        );
        const leftPoint = calculateRotateCoordinate(
          {
            x: currentPoint.x,
            y: start.point.y,
          },
          start.point,
          -layout.rotate
        );
        const width = Math.sqrt(
          (leftPoint.x - start.symmetric.x) ** 2 +
            (leftPoint.y - start.symmetric.y) ** 2
        );
        const center = {
          x: leftPoint.x - (leftPoint.x - start.symmetric.x) / 2,
          y: leftPoint.y + (start.symmetric.y - leftPoint.y) / 2,
        };
        if (width > 0) {
          layout.width = width;
          layout.x = center.x - width / 2;
          layout.y = center.y - layout.height / 2;
        }
      } else {
        if (start.width - offset.x < 0) {
          layout.width = 0;
          layout.x = start.layoutX + start.width;
        } else if (start.layoutX - offset.x < 0) {
          layout.width = start.layoutX + start.width;
          layout.x = 0;
        } else {
          layout.width = start.width - offset.x;
          layout.x = start.layoutX + offset.x;
        }
      }
      return layout;
    },
    "s-resize": (
      offset: Offset,
      _layout: Layout,
      start: MoveStart,
      e: MouseEvent
    ): Layout => {
      const layout = { ..._layout };
      if (layout.rotate !== 0) {
        const canvas = document.getElementsByClassName("infinite-canvas")[0];
        const editorRectInfo = canvas.getBoundingClientRect();
        const realTimeCoordinates = {
          x: e.clientX - editorRectInfo.left,
          y: e.clientY - editorRectInfo.top,
        };
        const currentPoint = calculateRotateCoordinate(
          realTimeCoordinates,
          start.point,
          layout.rotate
        );
        const bottomPoint = calculateRotateCoordinate(
          {
            x: start.point.x,
            y: currentPoint.y,
          },
          start.point,
          -layout.rotate
        );
        const height = Math.sqrt(
          (bottomPoint.x - start.symmetric.x) ** 2 +
            (bottomPoint.y - start.symmetric.y) ** 2
        );
        const center = {
          x: bottomPoint.x - (bottomPoint.x - start.symmetric.x) / 2,
          y: bottomPoint.y + (start.symmetric.y - bottomPoint.y) / 2,
        };
  
        layout.height = Math.round(height);
        layout.y = Math.round(center.y - height / 2);
        layout.x = Math.round(center.x - layout.width / 2);
      } else {
        if (start.height + offset.y < 0) {
          layout.height = 0;
        } else {
          layout.height = start.height + offset.y;
        }
      }
      return layout;
    },
    "se-resize": (
      offset: Offset,
      _layout: Layout,
      start: MoveStart,
      e: MouseEvent
    ): Layout => {
      const layout = { ..._layout };
      if (layout.rotate !== 0) {
        const canvas = document.getElementsByClassName("infinite-canvas")[0];
        const editorRectInfo = canvas.getBoundingClientRect();
        const realTimeCoordinates = {
          x: e.clientX - editorRectInfo.left,
          y: e.clientY - editorRectInfo.top,
        };
        const centerCoordinate = getCenterCoordinate(
          realTimeCoordinates,
          start.symmetric
        );
        const currentPoint = calculateRotateCoordinate(
          start.symmetric,
          centerCoordinate,
          layout.rotate
        );
        const symmetricPoint = calculateRotateCoordinate(
          realTimeCoordinates,
          centerCoordinate,
          layout.rotate
        );
        const width = symmetricPoint.x - currentPoint.x;
        const height = symmetricPoint.y - currentPoint.y;
        if (width > 0 && height > 0) {
          layout.width = width;
          layout.height = height;
          layout.x = currentPoint.x;
          layout.y = currentPoint.y;
        }
      } else {
        layout.width = start.width + offset.x;
        layout.height = start.height + offset.y;
        if (layout.width <= 0) {
          layout.width = 0;
        }
        if (layout.height <= 0) {
          layout.height = 0;
        }
      }
      return layout;
    },
    "sw-resize": (
      _: Offset,
      _layout: Layout,
      start: MoveStart,
      e?: MouseEvent
    ): Layout => {
      const layout = { ..._layout };
      if (!e) return _layout;
      if (layout.rotate !== 0) {
        const canvas = document.getElementsByClassName("infinite-canvas")[0];
        const editorRectInfo = canvas.getBoundingClientRect();
        const realTimeCoordinates = {
          x: e.clientX - editorRectInfo.left,
          y: e.clientY - editorRectInfo.top,
        };
        const centerCoordinate = getCenterCoordinate(
          realTimeCoordinates,
          start.symmetric
        );
        const currentPoint = calculateRotateCoordinate(
          start.symmetric,
          centerCoordinate,
          layout.rotate
        );
        const symmetricPoint = calculateRotateCoordinate(
          realTimeCoordinates,
          centerCoordinate,
          layout.rotate
        );
        const width = currentPoint.x - symmetricPoint.x;
        const height = symmetricPoint.y - currentPoint.y;
        if (width > 0 && height > 0) {
          layout.width = width;
          layout.height = height;
          layout.x = symmetricPoint.x;
          layout.y = currentPoint.y;
        }
      } else {
        const scaleFactor = 1 / props.scale; // 计算缩放修正因子
        const correct = {
          x: Math.round((start.x - Number(e.clientX)) * scaleFactor),
          y: Math.round((start.y - Number(e.clientY)) * scaleFactor),
        };
        layout.width = start.width + correct.x;
        layout.height = start.height - correct.y;
        layout.x = start.layoutX - correct.x;
        if (layout.width < 0) {
          layout.width = 0;
          layout.x = start.layoutX + start.width;
        }
        if (layout.height < 0) {
          layout.height = 0;
        }
      }
      return layout;
    },
    move: (offset: Offset, _layout: Layout, start: MoveStart): Layout => {
      const layout = { ..._layout };
      const resultX = start.layoutX + offset.x;
      const resultY = start.layoutY + offset.y;
      layout.x = resultX;
      layout.y = resultY;
      return layout;
    },
    rotate: (
      _offset: Offset,
      _layout: Layout,
      start: MoveStart,
      e?: MouseEvent
    ): Layout => {
      const layout = { ..._layout };
      if (!e) return layout;
      // 计算角度并标准化到[0, 360)范围
      const rawAngle =
        Math.atan2(e.layerY - start.center.y, e.layerX - start.center.x) /
        (Math.PI / 180);
      layout.rotate = Math.round(start.rotate + rawAngle - start.beforeAngle);
      return layout;
    },
  };
 */
